/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import { TransactionOverrides, TypedEventDescription, TypedFunctionDescription } from ".";

interface DumbContractInterface extends Interface {
  functions: {
    arrayParamLength: TypedFunctionDescription<{ encode([]: []): string }>;

    countupForEther: TypedFunctionDescription<{ encode([]: []): string }>;

    someAddress: TypedFunctionDescription<{ encode([]: []): string }>;

    twoUnnamedArgs: TypedFunctionDescription<{
      encode([, , ret]: [BigNumberish, BigNumberish, BigNumberish]): string;
    }>;

    returnSigned: TypedFunctionDescription<{ encode([offset]: [BigNumberish]): string }>;

    callWithBoolean: TypedFunctionDescription<{ encode([boolParam]: [boolean]): string }>;

    callWithArray2: TypedFunctionDescription<{ encode([arrayParam]: [(BigNumberish)[]]): string }>;

    testAddress: TypedFunctionDescription<{ encode([a]: [string]): string }>;

    counter: TypedFunctionDescription<{ encode([]: []): string }>;

    testString: TypedFunctionDescription<{ encode([a]: [string]): string }>;

    callWithBytes: TypedFunctionDescription<{ encode([byteParam]: [Arrayish]): string }>;

    callWithBooleanArray: TypedFunctionDescription<{
      encode([boolArrayParam]: [(boolean)[]]): string;
    }>;

    counterArray: TypedFunctionDescription<{ encode([,]: [BigNumberish]): string }>;

    countup: TypedFunctionDescription<{ encode([offset]: [BigNumberish]): string }>;

    returnAll: TypedFunctionDescription<{ encode([]: []): string }>;

    SOME_VALUE: TypedFunctionDescription<{ encode([]: []): string }>;

    counterWithOffset: TypedFunctionDescription<{ encode([offset]: [BigNumberish]): string }>;

    dynamicByteArray: TypedFunctionDescription<{ encode([]: []): string }>;

    testVoidReturn: TypedFunctionDescription<{ encode([]: []): string }>;

    testSmallUint: TypedFunctionDescription<{ encode([]: []): string }>;

    callWithDynamicByteArray: TypedFunctionDescription<{
      encode([dynamicBytes]: [Arrayish]): string;
    }>;

    byteArray: TypedFunctionDescription<{ encode([]: []): string }>;

    callWithArray: TypedFunctionDescription<{ encode([arrayParam]: [(BigNumberish)[]]): string }>;

    returnSmallUint: TypedFunctionDescription<{ encode([]: []): string }>;
  };

  events: {
    Deposit: TypedEventDescription<{
      encodeTopics([from, value]: [string | null, null]): string[];
    }>;
  };
}

export class DumbContract extends Contract {
  connect(signerOrProvider: Signer | Provider | string): DumbContract;
  attach(addressOrName: string): DumbContract;
  deployed(): Promise<DumbContract>;

  on(event: EventFilter | string, listener: Listener): DumbContract;
  once(event: EventFilter | string, listener: Listener): DumbContract;
  addListener(eventName: EventFilter | string, listener: Listener): DumbContract;
  removeAllListeners(eventName: EventFilter | string): DumbContract;
  removeListener(eventName: any, listener: Listener): DumbContract;

  interface: DumbContractInterface;

  functions: {
    arrayParamLength(): Promise<BigNumber>;

    countupForEther(overrides?: TransactionOverrides): Promise<ContractTransaction>;

    someAddress(): Promise<string>;

    twoUnnamedArgs(
      arg0: BigNumberish,
      arg1: BigNumberish,
      ret: BigNumberish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    returnSigned(offset: BigNumberish): Promise<BigNumber>;

    callWithBoolean(boolParam: boolean): Promise<boolean>;

    callWithArray2(arrayParam: (BigNumberish)[]): Promise<(BigNumber)[]>;

    testAddress(a: string): Promise<string>;

    counter(): Promise<BigNumber>;

    testString(a: string): Promise<string>;

    callWithBytes(
      byteParam: Arrayish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    callWithBooleanArray(boolArrayParam: (boolean)[]): Promise<(boolean)[]>;

    counterArray(arg0: BigNumberish): Promise<BigNumber>;

    countup(offset: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

    returnAll(): Promise<{
      0: BigNumber;
      1: BigNumber;
    }>;

    SOME_VALUE(): Promise<boolean>;

    counterWithOffset(offset: BigNumberish): Promise<BigNumber>;

    dynamicByteArray(): Promise<string>;

    testVoidReturn(): Promise<void>;

    testSmallUint(): Promise<number>;

    callWithDynamicByteArray(
      dynamicBytes: Arrayish,
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    byteArray(): Promise<string>;

    callWithArray(
      arrayParam: (BigNumberish)[],
      overrides?: TransactionOverrides,
    ): Promise<ContractTransaction>;

    returnSmallUint(): Promise<number>;
  };

  arrayParamLength(): Promise<BigNumber>;

  countupForEther(overrides?: TransactionOverrides): Promise<ContractTransaction>;

  someAddress(): Promise<string>;

  twoUnnamedArgs(
    arg0: BigNumberish,
    arg1: BigNumberish,
    ret: BigNumberish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  returnSigned(offset: BigNumberish): Promise<BigNumber>;

  callWithBoolean(boolParam: boolean): Promise<boolean>;

  callWithArray2(arrayParam: (BigNumberish)[]): Promise<(BigNumber)[]>;

  testAddress(a: string): Promise<string>;

  counter(): Promise<BigNumber>;

  testString(a: string): Promise<string>;

  callWithBytes(
    byteParam: Arrayish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  callWithBooleanArray(boolArrayParam: (boolean)[]): Promise<(boolean)[]>;

  counterArray(arg0: BigNumberish): Promise<BigNumber>;

  countup(offset: BigNumberish, overrides?: TransactionOverrides): Promise<ContractTransaction>;

  returnAll(): Promise<{
    0: BigNumber;
    1: BigNumber;
  }>;

  SOME_VALUE(): Promise<boolean>;

  counterWithOffset(offset: BigNumberish): Promise<BigNumber>;

  dynamicByteArray(): Promise<string>;

  testVoidReturn(): Promise<void>;

  testSmallUint(): Promise<number>;

  callWithDynamicByteArray(
    dynamicBytes: Arrayish,
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  byteArray(): Promise<string>;

  callWithArray(
    arrayParam: (BigNumberish)[],
    overrides?: TransactionOverrides,
  ): Promise<ContractTransaction>;

  returnSmallUint(): Promise<number>;

  filters: {
    Deposit(from: string | null, value: null): EventFilter;
  };

  estimate: {
    arrayParamLength(): Promise<BigNumber>;

    countupForEther(): Promise<BigNumber>;

    someAddress(): Promise<BigNumber>;

    twoUnnamedArgs(arg0: BigNumberish, arg1: BigNumberish, ret: BigNumberish): Promise<BigNumber>;

    returnSigned(offset: BigNumberish): Promise<BigNumber>;

    callWithBoolean(boolParam: boolean): Promise<BigNumber>;

    callWithArray2(arrayParam: (BigNumberish)[]): Promise<BigNumber>;

    testAddress(a: string): Promise<BigNumber>;

    counter(): Promise<BigNumber>;

    testString(a: string): Promise<BigNumber>;

    callWithBytes(byteParam: Arrayish): Promise<BigNumber>;

    callWithBooleanArray(boolArrayParam: (boolean)[]): Promise<BigNumber>;

    counterArray(arg0: BigNumberish): Promise<BigNumber>;

    countup(offset: BigNumberish): Promise<BigNumber>;

    returnAll(): Promise<BigNumber>;

    SOME_VALUE(): Promise<BigNumber>;

    counterWithOffset(offset: BigNumberish): Promise<BigNumber>;

    dynamicByteArray(): Promise<BigNumber>;

    testVoidReturn(): Promise<BigNumber>;

    testSmallUint(): Promise<BigNumber>;

    callWithDynamicByteArray(dynamicBytes: Arrayish): Promise<BigNumber>;

    byteArray(): Promise<BigNumber>;

    callWithArray(arrayParam: (BigNumberish)[]): Promise<BigNumber>;

    returnSmallUint(): Promise<BigNumber>;
  };
}
