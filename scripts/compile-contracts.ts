import { execSync } from 'child_process'
import { copyFileSync, mkdirSync, readdirSync, renameSync, rmdirSync } from 'fs'
import { resolve } from 'path'

import { bold, brightItalic } from './_common'

function main() {
  const files = findFiles()

  removeOutDir(files)
  generateABIs(files)
  renameUglyNames(files)
  copyTruffleV5(files)
}

main()

function findFiles() {
  const rootDir = resolve(__dirname, '..')
  const contractsDir = resolve(rootDir, 'contracts')
  const outDir = resolve(contractsDir, 'compiled')

  const solidityVersionDirs = readdirSync(contractsDir, { withFileTypes: true }).filter(
    (d) => d.isDirectory() && d.name.startsWith('v'),
  )
  const contracts = new Map(
    solidityVersionDirs.map((directory) => {
      const version = directory.name
      const fileNames = readdirSync(resolve(contractsDir, version), { withFileTypes: true })
        .filter((f) => f.isFile() && f.name.endsWith('.sol'))
        .map((f) => f.name)

      return [version, fileNames]
    }),
  )

  return {
    rootDir,
    contractsDir,
    outDir,
    contracts,
  }
}

type Files = ReturnType<typeof findFiles>

function removeOutDir({ outDir }: Files) {
  console.log(bold('Cleaning up contracts/abis'))

  try {
    rmdirSync(outDir, { recursive: true })
  } catch (e: any) {
    if (e.code !== 'ENOENT') {
      throw e
    }
  }
}

function generateABIs({ rootDir, contracts }: Files) {
  console.log(bold('Generating ABIs'))

  for (const [dirName, fileNames] of contracts.entries()) {
    const semver = dirName.replace(/^v/, '^')
    const contractPaths = fileNames.map((fileName) => `./contracts/${dirName}/${fileName}`).join(' ')

    console.log(bold(`Compiling ${fileNames.length} contracts with \`npx solc@${semver}\``))
    execSync(`npx solc@${semver} --abi ${contractPaths} --bin -o ./contracts/compiled/${dirName}`, {
      cwd: rootDir,
      stdio: ['ignore', 'ignore', 'inherit'],
    })
  }
}

/**
 * Rename ugly names generated by solc to something human redable.
 */
function renameUglyNames({ outDir, contracts }: Files) {
  console.log(bold('Renaming ABIs'))

  for (const version of contracts.keys()) {
    const directory = resolve(outDir, version)
    const outputs = readdirSync(directory)

    const fileNamesSeen = new Map<string, number>()
    const newNames: string[] = []
    for (const file of outputs) {
      const [, fileName, contractName, extension] = file.match(
        new RegExp(`^_?_?contracts_${version}_([A-Za-z0-9-]+)_sol_([A-Za-z0-9-]*)\\.([a-z]+)$`),
      )!

      let newName: string

      const timesSeen = fileNamesSeen.get(fileName) || 0
      if (timesSeen < 2) {
        fileNamesSeen.set(fileName, timesSeen + 1)
        newName = `${fileName}.${extension}`
      } else {
        newName = `${contractName}.${extension}`
      }

      newNames.push(newName)
      renameSync(resolve(directory, file), resolve(directory, newName))
    }

    console.log(
      `Renamed ${bold(newNames.length)} files in ${bold(version)}:` +
        brightItalic(newNames.reduce((a, v, i) => (i % 2 === 0 ? a + '\n' + v : a + ' ' + v), '')),
    )
  }
}

function copyTruffleV5({ rootDir, contractsDir, contracts }: Files) {
  console.log(bold('Copy truffle-v5 contracts'))

  const truffleV5ContractsDir = resolve(rootDir, 'packages/target-truffle-v5-test/contracts')

  // TODO: Truffle config doesn't allow configuring multiple versions
  const versions = ['v0.6.4']
  // We would rather use this: `const versions = [...contracts.keys()]`

  for (const version of versions) {
    mkdirSync(resolve(truffleV5ContractsDir, version), { recursive: true })
  }

  const contractRelativePaths = versions.flatMap((version) =>
    contracts.get(version)!.map((file) => `${version}/${file}`),
  )
  for (const path of contractRelativePaths) {
    copyFileSync(resolve(contractsDir, path), resolve(truffleV5ContractsDir, path))
  }
}
